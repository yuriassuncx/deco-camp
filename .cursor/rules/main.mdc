---
alwaysApply: true
---

# Deco MCP Template Development Guide

## Project Overview

This is a **Deco MCP (Model Context Protocol) server** template with a **React + Tailwind CSS frontend**. It provides a full-stack development environment where:
- The `/server` folder contains the MCP server (Cloudflare Workers + Deco runtime)
- The `/view` folder contains the React frontend (Vite + Tailwind CSS)
- The server serves both MCP endpoints AND the built frontend assets

## Project Structure

```
react-tailwind-view/
‚îú‚îÄ‚îÄ package.json          # Root workspace with dev/gen/deploy scripts
‚îú‚îÄ‚îÄ server/               # MCP Server (Cloudflare Workers + Deco)
‚îÇ   ‚îú‚îÄ‚îÄ main.ts          # Main server entry point
‚îÇ   ‚îú‚îÄ‚îÄ deco.gen.ts      # Generated types for integrations
‚îÇ   ‚îú‚îÄ‚îÄ wrangler.toml    # Cloudflare Workers config
‚îÇ   ‚îî‚îÄ‚îÄ package.json     # Server dependencies
‚îî‚îÄ‚îÄ view/                # React Frontend (Vite + Tailwind)
    ‚îú‚îÄ‚îÄ src/
    ‚îÇ   ‚îú‚îÄ‚îÄ main.tsx     # React app entry point
    ‚îÇ   ‚îú‚îÄ‚îÄ lib/rpc.ts   # RPC client for server communication
    ‚îÇ   ‚îú‚îÄ‚îÄ hooks/       # TanStack Query hooks for RPC calls
    ‚îÇ   ‚îú‚îÄ‚îÄ routes/      # React Router routes
    ‚îÇ   ‚îî‚îÄ‚îÄ components/  # UI components
    ‚îú‚îÄ‚îÄ package.json     # Frontend dependencies
    ‚îî‚îÄ‚îÄ vite.config.ts   # Vite configuration
```

## Development Workflow

### Root Commands (npm workspace)
- `npm run dev` - **Primary development command**
  - Starts frontend build in watch mode
  - Starts MCP server on port 8787
  - Server serves both API endpoints + frontend assets
  - Hot reload for both frontend and backend
  
- `npm run gen` - **Type generation**
  - Generates TypeScript types for deco integrations
  - Creates `server/deco.gen.ts` with typed RPC interfaces
  - Run this after adding new integrations in deco.chat

- `npm run gen:self` - **Self-type generation for your own tools**
  - Generates TypeScript types for your own server's tools and workflows
  - Requires the server to be running (`npm run dev`)
  - Copy the development URL from server logs (e.g., "https://localhost-48d64e92.deco.host")
  - Add /mcp to the path. So, for the URL https://localhost-48d64e92.deco.host you should set DECO_SELF_URL as https://localhost-48d64e92.deco.host/mcp.
  - Run: `DECO_SELF_URL=<your-dev-url> npm run gen:self`
  - Creates typed RPC interfaces for your own tools/workflows
  - Run this after adding new tools or workflows to your server

- `npm run deploy` - **Production deployment**
  - Builds frontend for production
  - Deploys to Cloudflare Workers
  - Makes app available at public URL

### Server Architecture (`/server`)

**Key Files:**
- `main.ts` - Main server with tools, workflows, and asset serving
- `deco.gen.ts` - Generated types for integrations (auto-generated)
- `wrangler.toml` - Cloudflare Workers config with asset binding

**Server Pattern:**
```typescript
// server/main.ts structure
import { withRuntime } from "@deco/workers-runtime";

// 1. Define tools (functions the MCP can call)
const createMyTool = (env: Env) => createTool({
  id: "MY_TOOL",
  description: "Tool description",
  inputSchema: z.object({ /* input schema */ }),
  outputSchema: z.object({ /* output schema */ }),
  execute: async ({ context }) => {
    // Tool logic here
    return { /* result */ };
  },
});

// 2. Define workflows (multi-step processes)
const createMyWorkflow = (env: Env) => {
  const step = createStepFromTool(createMyTool(env));
  return createWorkflow({
    id: "MY_WORKFLOW",
    inputSchema: z.object({ /* input */ }),
    outputSchema: z.object({ /* output */ }),
  }).then(step).commit();
};

// 3. Setup runtime with fallback to serve frontend
const { Workflow, ...runtime } = withRuntime<Env>({
  workflows: [createMyWorkflow],
  tools: [createMyTool],
  fetch: fallbackToView("/"), // Serves frontend assets
});

export { Workflow };
export default runtime;
```

### Frontend Architecture (`/view`)

**Key Files:**
- `src/main.tsx` - React app entry with TanStack Router setup
- `src/lib/rpc.ts` - RPC client for server communication
- `src/routes/` - TanStack Router routes
- `src/components/` - UI components with Tailwind CSS

**Frontend-to-Server Communication:**
```typescript
// view/src/lib/rpc.ts
import { createClient } from "@deco/workers-runtime/client";
import type { Env } from "../../../server/deco.gen.ts";

type SelfMCP = Env["SELF"];
export const client = createClient<SelfMCP>();
```

**Best Practice: Use TanStack Query Hooks for RPC Calls**

**‚ùå Avoid calling RPC client directly in components:**
```typescript
// DON'T DO THIS - Direct RPC calls in components
function MyComponent() {
  const [data, setData] = useState(null);
  
  useEffect(() => {
    client.MY_TOOL({ name: "example" }).then(setData);
  }, []);
  
  return <div>{data?.result}</div>;
}
```

**‚úÖ Recommended: Wrap RPC calls with TanStack Query hooks:**
```typescript
// view/src/hooks/useMyTool.ts
import { useQuery, useMutation, useQueryClient } from "@tanstack/react-query";
import { client } from "../lib/rpc";

// For read operations - use useQuery
export const useMyTool = (input: { name: string }) => {
  return useQuery({
    queryKey: ["myTool", input],
    queryFn: () => client.MY_TOOL(input),
    enabled: !!input.name, // Only run when input is valid
  });
};

// For write operations - use useMutation
export const useMyToolMutation = () => {
  const queryClient = useQueryClient();
  
  return useMutation({
    mutationFn: (input: { name: string }) => client.MY_TOOL(input),
    onSuccess: () => {
      // Invalidate related queries after successful mutation
      queryClient.invalidateQueries({ queryKey: ["myTool"] });
    },
  });
};

// For workflows - typically use useMutation
export const useStartMyWorkflow = () => {
  return useMutation({
    mutationFn: (input: { name: string }) => client.START_MY_WORKFLOW(input),
  });
};

// Usage in components:
function MyComponent() {
  const { data, isLoading, error } = useMyTool({ name: "example" });
  const myToolMutation = useMyToolMutation();
  const startWorkflow = useStartMyWorkflow();

  if (isLoading) return <div>Loading...</div>;
  if (error) return <div>Error: {error.message}</div>;

  return (
    <div>
      <p>Result: {data?.result}</p>
      <button 
        onClick={() => myToolMutation.mutate({ name: "new-example" })}
        disabled={myToolMutation.isPending}
      >
        {myToolMutation.isPending ? "Running..." : "Run Tool"}
      </button>
      <button 
        onClick={() => startWorkflow.mutate({ name: "workflow-input" })}
        disabled={startWorkflow.isPending}
      >
        Start Workflow
      </button>
    </div>
  );
}
```

**TanStack Router Pattern:**
```typescript
// view/src/routes/my-route.tsx
import { createRoute, type RootRoute } from "@tanstack/react-router";

function MyRouteComponent() {
  return (
    <div>
      <h1>My Route</h1>
      {/* Component content */}
    </div>
  );
}

// Export function that creates the route
export default (parentRoute: RootRoute) =>
  createRoute({
    path: "/my-route",
    component: MyRouteComponent,
    getParentRoute: () => parentRoute,
  });

// Add to main.tsx router tree:
import MyRoute from "./routes/my-route.tsx";

const routeTree = rootRoute.addChildren([
  indexRoute,
  MyRoute(rootRoute),
  // ... other routes
]);
```

**Navigation Best Practices:**

Use TanStack Router's type-safe navigation components and hooks for internal navigation:

```typescript
import { Link, useNavigate } from "@tanstack/react-router";

function NavigationExamples() {
  const navigate = useNavigate();

  const handleProgrammaticNavigation = () => {
    // Type-safe programmatic navigation
    navigate({ to: "/my-route" });
    
    // With search params
    navigate({ 
      to: "/my-route", 
      search: { filter: "active" } 
    });
    
    // With route params
    navigate({ 
      to: "/users/$userId", 
      params: { userId: "123" } 
    });
  };

  return (
    <div>
      {/* ‚úÖ Use Link for internal navigation */}
      <Link to="/my-route">Go to My Route</Link>
      
      {/* ‚úÖ Link with search params */}
      <Link to="/my-route" search={{ filter: "active" }}>
        Filtered Route
      </Link>
      
      {/* ‚úÖ Link with route params */}
      <Link to="/users/$userId" params={{ userId: "123" }}>
        User Profile
      </Link>
      
      {/* ‚úÖ External links use regular anchor tags */}
      <a href="https://external-site.com" target="_blank" rel="noopener noreferrer">
        External Link
      </a>
      
      {/* ‚úÖ Programmatic navigation */}
      <button onClick={handleProgrammaticNavigation}>
        Navigate Programmatically
      </button>
    </div>
  );
}
```

**‚ùå Avoid using anchor tags for internal navigation:**
```typescript
// DON'T DO THIS for internal routes
<a href="/my-route">Internal Link</a>

// This loses type safety and doesn't work with TanStack Router's features
```

**Navigation Guidelines:**
- Use `<Link>` component for internal route navigation with full type safety
- Use `useNavigate()` hook for programmatic navigation (form submissions, button clicks, etc.)
- Only use `<a>` tags for external links (different domains, mailto:, tel:, etc.)
- TanStack Router provides compile-time route validation and autocompletion

## Development Best Practices

### When Adding New Tools:
1. Add tool definition in `server/main.ts`
2. Include in `withRuntime` tools array
3. Run `npm run gen` to update external integration types
4. Start server with `npm run dev` and copy the development URL from logs
5. Run `DECO_SELF_URL=<your-dev-url> npm run gen:self` to generate self-types
6. Create TanStack Query hooks in `view/src/hooks/` to wrap RPC calls
7. Use the hooks in components instead of calling `client.YOUR_TOOL()` directly

### When Adding New Workflows:
1. Create workflow in `server/main.ts`
2. Include in `withRuntime` workflows array
3. Run `npm run gen` to update external integration types
4. Start server with `npm run dev` and copy the development URL from logs
5. Run `DECO_SELF_URL=<your-dev-url> npm run gen:self` to generate self-types
6. Create TanStack Query mutation hooks in `view/src/hooks/` to wrap workflow calls
7. Use the hooks in components instead of calling `client.START_YOUR_WORKFLOW()` directly

### When Adding New Routes:
1. Create route component in `view/src/routes/`
2. Export a function that takes a parent route and returns `createRoute()`
3. Add route to router tree in `view/src/main.tsx`
4. Use TanStack Router's typesafe `createRoute` pattern

### When Adding UI Components:
1. Use shadcn CLI to add new components: `cd view && npx shadcn@latest add <component-name>`
2. Use Tailwind CSS classes for styling
3. Leverage shadcn/ui components in `view/src/components/ui/`
4. Use `clsx` and `tailwind-merge` for conditional classes
5. Use lucide-react icons for consistent iconography (already installed)

### When Working with Database:
1. **Always use `getDb(env)`** - Never create direct database connections
2. **Schema changes**: Modify `server/schema.ts` then run `npm run db:generate`
3. **Migrations**: Applied automatically when using `getDb(env)` - no manual commands needed
4. **CRUD operations**: Follow the patterns in `server/tools.ts` (check existence before update/delete)
5. **Boolean handling**: Convert SQLite integers (0/1) to/from JavaScript booleans
6. **Error handling**: Wrap database operations in try-catch blocks
7. **Transactions**: Use `db.transaction()` for multi-step operations
8. **Types**: Leverage Drizzle's `InferSelectModel` and `InferInsertModel` for type safety

## Environment Setup

### Prerequisites:
- Node.js >=18.0.0
- npm >=8.0.0
- Deno >=2.0.0
- Deco CLI installed: `deno install -Ar -g -n deco jsr:@deco/cli`

### Initial Setup:
1. `deco login` - Authenticate with deco.chat
2. `npm install` - Install all dependencies
3. `npm run configure` - Configure the app with the desired name and select its workspace
4. `npm run dev` - Start development

## Integration with Deco Platform

### Adding External Integrations:
1. Go to deco.chat dashboard
2. Add integrations (APIs, databases, etc.)
3. Run `npm run gen` to get typed interfaces
4. Use typed clients in your tools/workflows

### Deployment:
- `npm run deploy` deploys to Cloudflare Workers
- App becomes available at public URL
- Can be used as MCP server by AI agents

## Database Management

This template includes **Drizzle ORM** with **SQLite** (Cloudflare Durable Objects) for persistent data storage.

### Database Architecture

**Key Files:**
- `server/schema.ts` - Database schema definitions using Drizzle ORM
- `server/db.ts` - Database connection and migration utilities
- `server/drizzle.config.ts` - Drizzle configuration for migrations
- `server/drizzle/` - Generated migration files

### Database Connection Pattern

**üî• CRITICAL: Always use `getDb(env)` function**

```typescript
import { getDb } from "./db.ts";
import { eq } from "drizzle-orm";
import { myTable } from "./schema.ts";

// ‚úÖ CORRECT: Always use getDb(env) in tools
export const createMyDatabaseTool = (env: Env) =>
  createTool({
    id: "MY_DATABASE_TOOL",
    description: "Interact with database",
    inputSchema: z.object({ /* input schema */ }),
    outputSchema: z.object({ /* output schema */ }),
    execute: async ({ context }) => {
      // ALWAYS get database connection this way
      const db = await getDb(env);
      
      // Perform database operations
      const result = await db.select().from(myTable);
      return { result };
    },
  });
```

**‚ùå NEVER do direct database connections:**
```typescript
// DON'T DO THIS - Never create direct connections
const db = drizzle(env);  // ‚ùå Missing migrations
const db = new Database(); // ‚ùå Wrong approach
```

### Database Schema Definition

Define your schema in `server/schema.ts`:

```typescript
// server/schema.ts
import { integer, sqliteTable, text } from "@deco/workers-runtime/drizzle";

export const todosTable = sqliteTable("todos", {
  id: integer("id").primaryKey(),
  title: text("title"),
  completed: integer("completed").default(0),
});

export const usersTable = sqliteTable("users", {
  id: integer("id").primaryKey(),
  email: text("email").notNull().unique(),
  name: text("name"),
  createdAt: integer("created_at", { mode: 'timestamp' }),
});
```

### Database Operations Patterns

**1. Create (Insert):**
```typescript
execute: async ({ context }) => {
  const db = await getDb(env);
  
  const newRecord = await db.insert(myTable).values({
    title: context.title,
    completed: 0,
  }).returning({ id: myTable.id });
  
  return { id: newRecord[0].id };
}
```

**2. Read (Select):**
```typescript
execute: async ({ context }) => {
  const db = await getDb(env);
  
  // Select all
  const allRecords = await db.select().from(myTable);
  
  // Select with conditions
  const filteredRecords = await db.select()
    .from(myTable)
    .where(eq(myTable.completed, 1));
  
  // Select single record
  const singleRecord = await db.select()
    .from(myTable)
    .where(eq(myTable.id, context.id))
    .limit(1);
  
  return { records: allRecords };
}
```

**3. Update:**
```typescript
execute: async ({ context }) => {
  const db = await getDb(env);
  
  // Check if record exists first
  const existing = await db.select()
    .from(myTable)
    .where(eq(myTable.id, context.id))
    .limit(1);
  
  if (existing.length === 0) {
    throw new Error("Record not found");
  }
  
  const updated = await db.update(myTable)
    .set({ title: context.newTitle })
    .where(eq(myTable.id, context.id))
    .returning();
  
  return { updated: updated[0] };
}
```

**4. Delete:**
```typescript
execute: async ({ context }) => {
  const db = await getDb(env);
  
  // Verify record exists before deletion
  const existing = await db.select()
    .from(myTable)
    .where(eq(myTable.id, context.id))
    .limit(1);
  
  if (existing.length === 0) {
    throw new Error("Record not found");
  }
  
  await db.delete(myTable).where(eq(myTable.id, context.id));
  
  return { success: true, deletedId: context.id };
}
```

### Migration Workflow

**1. Schema Changes:**
```bash
# After modifying server/schema.ts
npm run db:generate  # Generates migration files
```

**2. Migration Application:**
- Migrations are **automatically applied** when using `getDb(env)`
- No manual migration commands needed in production
- Migrations run lazily on first database access

**3. Migration Files:**
- Generated in `server/drizzle/` directory
- Version controlled and deployed with your app
- Applied automatically via `migrateWithoutTransaction`

### Database Best Practices

**1. Always Use getDb():**
```typescript
// ‚úÖ CORRECT - Every database operation
const db = await getDb(env);
```

**2. Handle Errors Gracefully:**
```typescript
execute: async ({ context }) => {
  const db = await getDb(env);
  
  try {
    const result = await db.select().from(myTable);
    return { result };
  } catch (error) {
    console.error("Database error:", error);
    throw new Error("Failed to fetch data");
  }
}
```

**3. Validate Before Operations:**
```typescript
// Always check if records exist before update/delete
const existing = await db.select()
  .from(myTable)
  .where(eq(myTable.id, context.id))
  .limit(1);

if (existing.length === 0) {
  throw new Error("Record not found");
}
```

### Database Schema Types

Drizzle automatically generates TypeScript types from your schema:

```typescript
import type { InferSelectModel, InferInsertModel } from "drizzle-orm";
import { todosTable } from "./schema.ts";

// Generated types
type Todo = InferSelectModel<typeof todosTable>;
type NewTodo = InferInsertModel<typeof todosTable>;

// Use in tool schemas
outputSchema: z.object({
  todo: z.object({
    id: z.number(),
    title: z.string().nullable(),
    completed: z.boolean(),
  }),
})
```

### Common Database Queries

**Filtering and Sorting:**
```typescript
import { eq, ne, gt, lt, and, or, desc, asc } from "drizzle-orm";

// Multiple conditions
const results = await db.select()
  .from(todosTable)
  .where(and(
    eq(todosTable.completed, 0),
    ne(todosTable.title, null)
  ))
  .orderBy(desc(todosTable.id));

// OR conditions
const results = await db.select()
  .from(todosTable)
  .where(or(
    eq(todosTable.completed, 1),
    gt(todosTable.id, 100)
  ));
```

**Joins (if using multiple tables):**
```typescript
const results = await db.select({
  todo: todosTable,
  user: usersTable,
})
.from(todosTable)
.leftJoin(usersTable, eq(todosTable.userId, usersTable.id));
```

## Common Patterns

### Error Handling:
```typescript
// In tools
execute: async ({ context }) => {
  const result = await someAsyncOperation(context);
  if (!result.ok) {
    throw new Error("...")
  }
  return result;
}
```

### Frontend State Management:
- Use `@tanstack/react-query` for server state management
- Prefer wrapping RPC client calls in TanStack Query hooks over direct calls in components
- Create custom hooks in `view/src/hooks/` for each tool/workflow:
  - Use `useQuery` for read operations (data fetching)
  - Use `useMutation` for write operations (tools/workflows that modify state)
- Use TanStack Router for typesafe navigation and routing state
- Use React hooks for component-local state

### TanStack Query Hook Patterns:

```typescript
// view/src/hooks/useTools.ts - Example comprehensive hook patterns

import { useQuery, useMutation, useQueryClient, useInfiniteQuery } from "@tanstack/react-query";
import { client } from "../lib/rpc";

// 1. Simple data fetching with useQuery
export const useGetData = (id: string) => {
  return useQuery({
    queryKey: ["data", id],
    queryFn: () => client.GET_DATA({ id }),
    enabled: !!id, // Only run when id is provided
    staleTime: 5 * 60 * 1000, // Consider data fresh for 5 minutes
  });
};

// 2. Mutation with optimistic updates and cache invalidation
export const useUpdateData = () => {
  const queryClient = useQueryClient();
  
  return useMutation({
    mutationFn: (data: { id: string; value: string }) => 
      client.UPDATE_DATA(data),
    
    // Optimistic update
    onMutate: async (newData) => {
      await queryClient.cancelQueries({ queryKey: ["data", newData.id] });
      const previousData = queryClient.getQueryData(["data", newData.id]);
      queryClient.setQueryData(["data", newData.id], newData);
      return { previousData };
    },
    
    // Rollback on error
    onError: (err, newData, context) => {
      if (context?.previousData) {
        queryClient.setQueryData(["data", newData.id], context.previousData);
      }
    },
    
    // Refetch on success
    onSuccess: (data, variables) => {
      queryClient.invalidateQueries({ queryKey: ["data", variables.id] });
    },
  });
};

// 3. Long-running workflow with status polling
export const useWorkflowWithPolling = () => {
  return useMutation({
    mutationFn: (input: { name: string }) => 
      client.START_LONG_WORKFLOW(input),
    
    onSuccess: (data) => {
      // Start polling for workflow status
      if (data.workflowId) {
        // You can trigger a separate useQuery to poll status
        // or use queryClient.refetchQueries to update related data
      }
    },
  });
};

// 4. Dependent queries - only run when previous data is available
export const useUserProfile = (userId: string) => {
  return useQuery({
    queryKey: ["userProfile", userId],
    queryFn: () => client.GET_USER_PROFILE({ userId }),
    enabled: !!userId,
  });
};

export const useUserPreferences = (userId: string) => {
  const { data: userProfile } = useUserProfile(userId);
  
  return useQuery({
    queryKey: ["userPreferences", userId],
    queryFn: () => client.GET_USER_PREFERENCES({ userId }),
    enabled: !!userProfile, // Only run after user profile loads
  });
};

// 5. Infinite query for paginated data
export const useInfiniteData = (filters: any) => {
  return useInfiniteQuery({
    queryKey: ["infiniteData", filters],
    queryFn: ({ pageParam = 0 }) => 
      client.GET_PAGINATED_DATA({ ...filters, page: pageParam }),
    getNextPageParam: (lastPage) => lastPage.nextPage,
    initialPageParam: 0,
  });
};
```

### Component Usage Examples:

```typescript
// ‚úÖ CORRECT: Using TanStack Query hooks
function DataComponent({ id }: { id: string }) {
  const { data, isLoading, error } = useGetData(id);
  const updateMutation = useUpdateData();
  const workflowMutation = useWorkflowWithPolling();

  if (isLoading) return <div>Loading...</div>;
  if (error) return <div>Error: {error.message}</div>;

  return (
    <div>
      <h2>{data?.title}</h2>
      <button 
        onClick={() => updateMutation.mutate({ id, value: "new value" })}
        disabled={updateMutation.isPending}
      >
        {updateMutation.isPending ? "Updating..." : "Update"}
      </button>
      
      <button 
        onClick={() => workflowMutation.mutate({ name: "process" })}
        disabled={workflowMutation.isPending}
      >
        {workflowMutation.isPending ? "Processing..." : "Start Process"}
      </button>
    </div>
  );
}
```

### Styling:
- Tailwind CSS for utility-first styling
- shadcn/ui components for consistent design
- Use `cn()` utility for conditional classes

## Debugging Tips

- Server logs appear in terminal during `npm run dev`
- Use browser dev tools for frontend debugging

This template provides a complete full-stack development environment for building MCP servers with modern React frontends. Focus on adding your business logic in tools and workflows while leveraging the typed RPC communication between frontend and backend.
